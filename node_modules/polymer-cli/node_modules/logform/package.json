{
  "_args": [
    [
      "logform@https://registry.npmjs.org/logform/-/logform-1.10.0.tgz",
      "/home/diogo/www/node_modules/polymer-cli"
    ]
  ],
  "_from": "logform@https://registry.npmjs.org/logform/-/logform-1.10.0.tgz",
  "_id": "logform@1.10.0",
  "_inCache": true,
  "_location": "/polymer-cli/logform",
  "_phantomChildren": {},
  "_requested": {
    "name": "logform",
    "raw": "logform@https://registry.npmjs.org/logform/-/logform-1.10.0.tgz",
    "rawSpec": "https://registry.npmjs.org/logform/-/logform-1.10.0.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/logform/-/logform-1.10.0.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "/polymer-cli/polymer-build/plylog",
    "/polymer-cli/polymer-build/winston"
  ],
  "_resolved": "https://registry.npmjs.org/logform/-/logform-1.10.0.tgz",
  "_shasum": "c9d5598714c92b546e23f4e78147c40f1e02012e",
  "_shrinkwrap": null,
  "_spec": "logform@https://registry.npmjs.org/logform/-/logform-1.10.0.tgz",
  "_where": "/home/diogo/www/node_modules/polymer-cli",
  "author": {
    "email": "charlie.robbins@gmail.com",
    "name": "Charlie Robbins"
  },
  "browser": "dist/browser.js",
  "bugs": {
    "url": "https://github.com/winstonjs/logform/issues"
  },
  "dependencies": {
    "colors": "^1.2.1",
    "fast-safe-stringify": "^2.0.4",
    "fecha": "^2.3.3",
    "ms": "^2.1.1",
    "triple-beam": "^1.2.0"
  },
  "description": "An mutable object-based log format designed for chaining & objectMode streams.",
  "devDependencies": {
    "assume": "^2.0.1",
    "babel-cli": "^6.26.0",
    "babel-preset-env": "^1.7.0",
    "eslint-config-populist": "^4.1.0",
    "mocha": "^5.1.1",
    "nyc": "^11.7.1",
    "rimraf": "^2.6.2"
  },
  "homepage": "https://github.com/winstonjs/logform#readme",
  "keywords": [
    "format",
    "logging",
    "winston",
    "winstonjs"
  ],
  "license": "MIT",
  "main": "index.js",
  "name": "logform",
  "optionalDependencies": {},
  "readme": "# logform\n\nAn mutable object-based log format designed for chaining & objectMode streams.\n\n``` js\nconst { format } = require('logform');\n\nconst alignedWithColorsAndTime = format.combine(\n  format.colorize(),\n  format.timestamp(),\n  format.align(),\n  format.printf(info => `${info.timestamp} ${info.level}: ${info.message}`)\n);\n```\n\n- [`info` Objects](#info-objects)\n- [Understanding formats](#understanding-formats)\n  - [Combining formats](#combining-formats)\n  - [Filtering `info` objects](#filtering-info-objects)\n\n## `info` Objects\n\nThe `info` parameter provided to a given format represents a single log message. The object itself is mutable. Every `info` must have at least the `level` and `message` properties:\n\n``` js\n{\n  level: 'info',                 // Level of the logging message  \n  message: 'Hey! Log something?' // Descriptive message being logged.\n}\n```\n\n`logform` itself exposes several additional properties:\n\n- `splat`: string interpolation splat for `%d %s`-style messages.\n- `timestamp`: timestamp the message was received.\n- `label`: custom label associated with each message.\n\nAs a consumer you may add whatever properties you wish – _internal state is maintained by `Symbol` properties:_\n\n- `Symbol.for('level')` _**(READ-ONLY)**:_ equal to `level` property. Is treated as immutable by all code.\n- `Symbol.for('message'):` complete string message set by \"finalizing formats\": `json`, `logstash`, `printf`, `prettyPrint`, and `simple`. \n\n## Understanding formats\n\nFormats are prototypal objects (i.e. class instances) that define a single method: `transform(info, opts)` and return the mutated `info`\n\n- `info`: an object representing the log message.\n- `opts`: setting specific to the current instance of the format.\n\nThey are expected to return one of two things:\n\n- **An `info` Object** representing the modified `info` argument. Object references need not be preserved if immutability is preferred. All current built-in formats consider `info` mutable, but [immutablejs] is being considered for future releases.\n- **A falsey value** indicating that the `info` argument should be ignored by the caller. (See: [Filtering `info` Objects](#filtering-info-objects)) below.\n\n`logform.format`  is designed to be as simple as possible. To define a new format simple pass it a `transform(info, opts)` function to get a new `Format`. \n\nThe named `Format` returned can be used to create as many copies of the given `Format` as desired:\n\n``` js\nconst { format } = require('logform');\n\nconst volume = format((info, opts) => {\n  if (opts.yell) {\n    info.message = info.message.toUpperCase(); \n  } else if (opts.whisper) {\n    info.message = info.message.toLowerCase();\n  }\n\n  return info;\n});\n\n// `volume` is now a function that returns instances of the format.\nconst scream = volume({ yell: true });\nconsole.dir(scream.transform({\n  level: 'info',\n  message: `sorry for making you YELL in your head!`\n}, scream.options));\n// {\n//   level: 'info'\n//   message: 'SORRY FOR MAKING YOU YELL IN YOUR HEAD!'\n// }\n\n// `volume` can be used multiple times to create different formats.\nconst whisper = volume({ whisper: true });\nconsole.dir(whisper.transform({ \n  level: 'info', \n  message: `WHY ARE THEY MAKING US YELL SO MUCH!` \n}), whisper.options);\n// {\n//   level: 'info'\n//   message: 'why are they making us yell so much!'\n// }\n```\n\n### Combining formats\n\nAny number of formats may be combined into a single format using `format.combine`. Since `format.combine` takes no `opts`, as a convenience it returns pre-created instance of the combined format.\n\n``` js\nconst { format } = require('logform');\nconst { combine, timestamp, label } = format;\n\nconst labelTimestamp = combine(\n  label({ label: 'right meow!' }),\n  timestamp()\n);\n\nconst info = labelTimestamp.transform({\n  level: 'info',\n  message: 'What time is the testing at?'\n});\n\nconsole.dir(info);\n// { level: 'info',\n//   message: 'What time is the testing at?',\n//   label: 'right meow!',\n//   timestamp: '2017-09-30T03:57:26.875Z' }\n```\n\n### Filtering `info` Objects\n\nIf you wish to filter out a given `info` Object completely then simply return a falsey value.\n\n``` js\nconst ignorePrivate = format((info, opts) => {\n  if (info.private) { return false; }\n  return info;\n});\n\nconsole.dir(ignorePrivate.transform({\n  level: 'error',\n  message: 'Public error to share'\n}));\n// { level: 'error', message: 'Public error to share' }\n\nconsole.dir(ignorePrivate.transform({\n  level: 'error',\n  private: true,\n  message: 'This is super secret - hide it.'\n}));\n// false\n```\n\nUse of `format.combine` will respect any falsey values return and stop evaluation of later formats in the series. For example:\n\n``` js\nconst { format } = require('logform');\nconst { combine, timestamp, label } = format;\n\nconst willNeverThrow = format.combine(\n  format(info => { return false })(), // Ignores everything\n  format(info => { throw new Error('Never reached') })()\n);\n\nconsole.dir(willNeverThrow.transform({\n  level: 'info',\n  message: 'wow such testing'\n}))\n```\n\n## Tests\n\nTests are written with `mocha`, `assume`, and `nyc`. They can be run with `npm`:\n\n```\nnpm test\n```\n\n##### LICENSE: MIT\n##### AUTHOR: [Charlie Robbins](https://github.com/indexzero)\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/winstonjs/logform.git"
  },
  "scripts": {
    "build": "rimraf dist && babel *.js -d ./dist",
    "lint": "populist *.js test/*.js examples/*.js",
    "prepublishOnly": "npm run build",
    "pretest": "npm run lint && npm run build",
    "test": "nyc mocha test/*.test.js"
  },
  "types": "./index.d.ts",
  "version": "1.10.0"
}
